- [Esercizio c1](#esercizio-c1)
- [Esercizio c2](#esercizio-c2)
- [Esercizio g1](#esercizio-g1)
- [Esercizio g2](#esercizio-g2)


# Esercizio c1
In un porto con una sola banchina utilizzabile occorre caricare cereali sulle navi. I camion portano i cereali al porto. Una sola nave alla volta può essere attraccata al molo, un solo camion alla volta scarica i cereali nella nave.

Il codice eseguito da ogni nave è:

	nave[i] process:
		porto.attracca(capacità)
		porto.salpa()
		... naviga verso la destinazione

Il codice di ogni camion è:

	camion[j] process:
		while (1):
			quantità = carica_cereali()
			porto.scarica(quantità)

- I camion fanno la spola dai depositi alla nave.
- La nave arriva vuota e può salpare solo se è stata completamente riempita [la somma delle quantità scaricate dai camion raggiunge la capacità indicata come parametro della funzione attracca].
- Se un camion può scaricare solo parzialmente il suo carico rimane in porto e aspetta di completare l'operazione con la prossima nave che attraccherà al molo.

Scrivere il monitor porto.

```pseudocode
monitor porto:
	procedure entry attracca(): 

	procedure entry salpa(): 

	procedure entry scarica(): 
	
```

# Esercizio c2
Dato un servizio di message passing asincrono implementare un servizio di message passing testardo che consegna solo i messaggi ricevuti due volte con il medesimo contenuto da qualsiasi mittente [i due messaggi uguali possono provenire da mittenti diversi]. Il servizio di message passing testardo prevede due funzioni:

	void tsend(msg_t msg, pid_t dest)
	msg_t trecv(void)

Il message passing testardo ha lo stesso potere espressivo del message passing asincrono?

```pseudocode
void tsend(msg_t msg, pid_t dest):

msg_t trecv(void):
```

# Esercizio g1
Fornire un elenco di incongruenze che poccono venir rilevate dal fsck [file system check] applicato a file system di tipo UNIX [e.g. ext2, bffs]. Per ogni tipo di incongruenza indicare come viene riscontrata e con quali operazioni di fsck può ripristinare la coerenza.

# Esercizio g2
rispondere alle seguenti domande [motivando opportinamente le risposte]:

a. perchè un algoritmo di rimpiazzamento a stack non può essere soggetto di anomalia di Belady?

b. le password [criptate] nei sistemi UNIX moderni sono memorizzate in un file inaccessibile agli utenti [`/etc/shadow`]. Perchè?

c. nello scheduler di tipo SRTF [versione preemptive di STF], il tempo residuo può diventare negativo. Perchè?

d. quando si usano dischi a stato solido i file system vengono configurati in modo da non aggiornare il tempo di ultimo accesso ai file [noatime]. Perchè?

## Risposte
- a. 

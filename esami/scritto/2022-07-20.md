[üîólink testo d'esame](https://csunibo.github.io/sistemi-operativi/prove/scritto/scritto-2022-07-20-testo.pdf)

- [Esercizio c1](#esercizio-c1)
- [Esercizio c2](#esercizio-c2)
- [Esercizio g1](#esercizio-g1)
- [Esercizio g2](#esercizio-g2)
	- [Risposte](#risposte)
---
# Esercizio c1
In un porto con una sola banchina utilizzabile occorre caricare cereali sulle navi. I camion portano i cereali al porto. Una sola nave alla volta pu√≤ essere attraccata al molo, un solo camion alla volta scarica i cereali nella nave.

Il codice eseguito da ogni nave √®:

	nave[i] process:
		porto.attracca(capacit√†)
		porto.salpa()
		... naviga verso la destinazione

Il codice di ogni camion √®:

	camion[j] process:
		while (1):
			quantit√† = carica_cereali()
			porto.scarica(quantit√†)

- I camion fanno la spola dai depositi alla nave.
- La nave arriva vuota e pu√≤ salpare solo se √® stata completamente riempita [la somma delle quantit√† scaricate dai camion raggiunge la capacit√† indicata come parametro della funzione attracca].
- Se un camion pu√≤ scaricare solo parzialmente il suo carico rimane in porto e aspetta di completare l'operazione con la prossima nave che attraccher√† al molo.

Scrivere il monitor porto.

```pseudocode
monitor porto:
	navi = 0			// quante navi sono al porto
	MAX = 0				// capacit√† max della nave [cereali max]
	cereali_nave = 0	// quanti cereali sono sulla nave
	waiting_cereali = 0 // cereali sul camion che aspetta la prossima nave
	condition camion_ok2scarica, nave_ok2salpa, ok2attracca

	procedure entry attracca(capacita): 
		navi++						// aggiungo la nave al porto
		if (navi > 1)			// Ho delle navi in attesa nel porto che non possono prendere cereali?
			ok2attracca.wait()	// aspettano!
		// questo lo controllo gi√† in salpa, non serve farlo anche qui giusto?
		// if (cereali_nave == 0 )		// Se la nave √® vuota
		// 	nave_ok2salpa.wait()	// la nave aspetta a salpare, deve essere caricata!		
		MAX = capacita		// salvo quanti cereali servono alla nave
		if (waiting_cereali > 0 && navi > 0) 	// Ho dei cereali in attesa di una nave e ho una nave ?
			cereali_nave += waiting_cereali 	// aggiungo i cereali in attesa alla nave
			waiting_cereali = 0 				// azzero i cereali in attesa perch√® sono stati caricati
			camion_ok2scarica.signal()    		// il camion pu√≤ continuare a scaricare

	procedure entry salpa(): 		
		if (cereali_nave != MAX) // la nave non √® piena
			nave_ok2salpa.wait()			
		navi--  				// tolgo una nave dal porto
		nave_ok2salpa.signal() 	// la nave pu√≤ partire
		if (navi > 1)				// Ho delle navi che attendono di attraccare?
			ok2attracca.signal() 	// do il segnale che pu√≤ attraccare
		
	procedure entry scarica(quantita): 	
		if (cereali_nave > MAX)
			waiting_cereali = cereali_nave-MAX 	// salvo i cereali che non sono stati scaricati
			cereali_nave = MAX  		// tolgo i cereali che non ci stanno dalla nave
			camion_ok2scarica.wait() 	// il camion deve attendere la prossima nave
		cereali_nave += quantita 	// carico i cereali sulla nave
		camion_ok2scarica.signal() 	// il camion √® vuoto e pu√≤ andare e lasciare il posto ad altri
```

# Esercizio c2
Dato un servizio di message passing asincrono implementare un servizio di message passing testardo che consegna solo i messaggi ricevuti due volte con il medesimo contenuto da qualsiasi mittente [i due messaggi uguali possono provenire da mittenti diversi]. Il servizio di message passing testardo prevede due funzioni:

	void tsend(msg_t msg, pid_t dest)
	msg_t trecv(void)
Il message passing testardo ha lo stesso potere espressivo del message passing asincrono?

```pseudocode
//ho a disposizione:	asincrono => asend, arecv
//devo implementare:	testardo

	// invia solo messaggi ricevuti 2 volte con lo stesso testo
void tsend(msg_t msg, pid_t dest):
	asend(<qualcosa, msg>, dest)
	
msg_t trecv(void):
	msg = arecv(ANY)
```
---
# Esercizio g1
Fornire un elenco di incongruenze che poccono venir rilevate dal fsck [file system check] applicato a file system di tipo UNIX [e.g. ext2, bffs]. Per ogni tipo di incongruenza indicare come viene riscontrata e con quali operazioni di fsck pu√≤ ripristinare la coerenza.

# Esercizio g2
rispondere alle seguenti domande [motivando opportinamente le risposte]:

a. perch√® un algoritmo di rimpiazzamento a stack non pu√≤ essere soggetto di anomalia di Belady?

b. le password [criptate] nei sistemi UNIX moderni sono memorizzate in un file inaccessibile agli utenti [`/etc/shadow`]. Perch√®?

c. nello scheduler di tipo SRTF [versione preemptive di STF], il tempo residuo pu√≤ diventare negativo. Perch√®?

d. quando si usano dischi a stato solido i file system vengono configurati in modo da non aggiornare il tempo di ultimo accesso ai file [noatime]. Perch√®?

## Risposte
- a. 
- b.
- c. Nello scheduler di tipo SRTF il tempo residuo pu√≤ diventare negativo per una sottostima del tempo di completamento del processo. Si verifica quando l'algoritmo sottostima la quantit√† di tempo necessaria per completare il processo corrente e lo scheduler passa ad un altro processo prima che il processo corrente sia effettivamente completato.
- d. 
